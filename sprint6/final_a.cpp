/*

Отчет: https://contest.yandex.ru/contest/25070/run-report/139444379/

Принцип работы:
Реализация поиска минимального остовного дерева выполнена с использованием алгоритма Прима.

Граф представлен в виде списков смежности. Для выбора минимального по весу ребра используется приоритетная очередь,
в которую помещаются все рёбра, инцидентные текущей вершине дерева. На каждой итерации извлекается ребро с минимальным весом,
и если его вторая вершина ещё не добавлена в остов, она добавляется, а её рёбра тоже помещаются в очередь.

Изначально в графе может быть несколько компонент, поэтому в конце проверяется наличие непройденных вершин.
Если они есть, значит в графе несколько компонент и единое оставное дерево построить нельзя.

Вычислительная сложность:
    Функция add имеет итоговую сложность O(E log E), где E инцидентность вершины.
    Если граф плотный, то инцидентность всех вершин будет очень высокая, соответственно для каждой вершины будет добавлено
    соседей в очередь O(E) раз и каждое добавление в очередь занимает еще O(log E), так как в приоритетной очереди будет выполнено
    просеивание вверх.

    Функция find_mft имеет итоговую сложность O(E log E), где E количество всех ребер в графе.
    Цикл в этой функции в худшем случае будет работать за O(E), так как не на каждой итерации может быть вызвана функция add
    и тем самым уменьшить размер массива not_added. Получается, что в худшем случае в плотном графе будет много холостых итераций,
    где not_added не уменьшается, а просто перебираются ребра уже добавленной вершины.
    На каждой итерации цикла происходит извлечение из приоритетной очереди с просеиванием вниз, которое
    тоже занимает O(log E) в плотных графах. Если граф разреженный, то количество элементов в приоритетной очереди будет
    близко к количеству вершин, и каждая итерация будет занимать O(log V).

    Итоговая сложность алгоритма выходит O(E log E) для плотных графов, O(E log V) для разреженных.

Пространственная сложность:
    Массив not_added занимают O(V) дополнительной памяти, по количеству вершин.
    Приоритетная очередь занимает O(E) памяти, по количеству ребер.
    Массив со списками связанности в среднем случае занимает O(V + E) памяти, в худшем на очень плотных графах O(V^2).

    Итоговая пространственная сложность в среднем случае будет O(V + E).

*/
#include <iostream>
#include <queue>
#include <tuple>
#include <unordered_set>
#include <vector>

using namespace std;

struct compare {
    bool operator() (const tuple<int, int>& a, const tuple<int, int>& b) const {
        return get<1>(a) < get<1>(b);
    }
};

vector<vector<tuple<int, int>>> adjacency;
unordered_set<int> not_added;
priority_queue<tuple<int, int>, vector<tuple<int, int>>, compare> priority;

void add(const int v) {
    not_added.erase(v);

    for (const auto& e : adjacency[v]) {
        if (not_added.contains(get<0>(e))) {
            priority.push(e);
        }
    }
}

int find_mst(const int start) {
    int result = 0;
    add(start);

    while (!not_added.empty() && !priority.empty()) {
        auto e = priority.top();
        priority.pop();

        if (not_added.contains(get<0>(e))) {
            result += get<1>(e);
            add(get<0>(e));
        }
    }

    return result;
}

int main() {
    int V, E;
    cin >> V >> E;
    adjacency.resize(V);

    int u, v, w;
    for (int i = 0; i < E; i++) {
        cin >> u >> v >> w;

        u--;
        v--;

        adjacency[u].emplace_back(v, w);
        adjacency[v].emplace_back(u, w);

        if (!not_added.contains(u)) {
            not_added.insert(u);
        }

        if (!not_added.contains(v)) {
            not_added.insert(v);
        }
    }

    const int weight = E ? find_mst(u) : 0;

    if ((!E && V > 1) || !not_added.empty()) {
        cout << "Oops! I did it again" << endl;
    } else {
        cout << weight << endl;
    }
}
