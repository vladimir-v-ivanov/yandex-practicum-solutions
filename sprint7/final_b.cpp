/*
Отчет: https://contest.yandex.ru/contest/25597/run-report/140356312/

Принцип работы:
    Данный алгоритм использует вложенные циклы для проверки можно ли набрать сумму, равную половине суммы всех очков.
    Если общая сумма всех очков нечетная, то значит по умолчанию разделись очки на две равные суммы нельзя.
    Если сумма четная, то внешний цикл начинает перебирать очки одно за другим, чтобы определить, какие суммы можно набрать
    с каждым из очков.
    Внутренний цикл осуществляет поиск таких сумм, начиная от самой искомой - половины, постепенно уменьшая ее на 1 на каждой итерации.
    Таким образом, после завершения внутреннего цикла для какого-либо из очков, в массиве dp мы будем иметь true на суммах, которые можно
    набрать с текущим очком.
    Что хранится в массиве dp - в нем хранятся промежуточные суммы, которые можно набрать с каждым из очков.
    Базовый случай это dp[0]=true, так как 0 сумму не нужно набирать.
    Переход динамики - на каждой итерации мы проверяем можно ли набрать искомую сумму, используя уже найденные суммы в массиве dp минус текущее очко.
    Если например искомая сумма 7, а текущее очко 5, то мы проверяем, если dp[7-5] == true, значит сумма 2 уже известна, и может быть набрана и,
    прибавив к ней текущее очко 5, получится искомая сумма. Если не набирается, то уменьшаем искомую сумму на 1, и все то же самое.
    Ответ на исходный вопрос будет в наибольшем индексе массива dp. Так как для каждого очка мы начинаем проверять можем ли набрать нужную
    сумму начиная с самой искомой суммы (половина от всей), то если на каком-либо шаге она наберется, то данный индекс будет true.

Вычислительная сложность:
    Вычислительная сложность O(N * M), где N это общее количество очков, а M это сумма очков равная половине.

Пространственная сложность:
    Пространственная сложность O(N), где N это размер массива dp.
*/

#include <iostream>
#include <vector>

using namespace std;

int main() {
    int len;
    cin >> len;

    vector<int> nums(len);
    int total = 0;

    for (int i = 0; i < len; i++) {
        cin >> nums[i];
        total += nums[i];
    }

    if (total % 2 != 0) {
        cout << "False" << endl;
        return 0;
    }

    vector dp(total / 2 + 1, false);
    dp[0] = true;

    for (int i = 0; i < len; i++) {
        const int curr = nums[i];

        for (int j = total / 2; j >= curr; j--) {
            if (dp[j - curr]) {
                dp[j] = true;
            }
        }
    }

    if (dp[total / 2]) {
        cout << "True" << endl;
    } else {
        cout << "False" << endl;
    }
}
