/*
Отчет: https://contest.yandex.ru/contest/25597/run-report/140467153/

Принцип работы:
    Применен алгоритм Вагнера-Фишера.
    Массив dp представляет собой матрицу размером 2 на M+1.
    При проходе вложенными циклами по строкам, i - по первой строке и j - по второй строке, то в dp[write_row][j] хранится число -
    количество минимальных изменений на текущих позициях, которые нужно было сделать, чтобы превратить первую строку во вторую.
    Переменная write_row чередуется между 0 и 1 для заполнения первого измерения массива поочереди. Переменная read_row соответственно противоположная
    строка из которой считываются значения. На каждой итерации внешнего цикла эти строки меняются местами.
    Базовый случай для задачи это заранее вычисленное количество изменений для строк с 0 символов.
    Например, если первая строка пустая, то dp[0][0] = 0, dp[0][1] = 1 и т.д. Что означает добавить все символы второй строки в первую.
    И точно так же, если вторая строка пустая, а первая нет.
    Эти действия описаны в самых первых двух циклах. Так же базовый случай для dp[0][0]=0.
    Переход динамики зависит от того, являются ли символы на текущих позициях одинаковыми или нет.
    Если символы одинаковые, то нужно знать ответ только одной подзадачи, для dp[write_row][j] это dp[read_row][j-1].
    Если символы разные, то нужно знать три ответа, для вариантов удаления, вставки и замены, в соответствии с алгоритмом -
    min(
        dp[read_row][j] + 1,
        dp[write_row][j-1] + 1,
        dp[read_row][j-1] + 1
    ).

    Ответ будет располагаться в нижнем правом углу матрицы, так как обход идет слева направо, сверху вниз.

Вычислительная сложность:
    Вычислительная сложность O(N * M), где N и M это длины обеих строк.

Пространственная сложность:
    Пространственная сложность O(M), где M это длина второй строки.
*/

#include <iostream>
#include <vector>

using namespace std;

int main() {
    string line1;
    string line2;
    getline(cin,line1);
    getline(cin,line2);

    const int n = static_cast<int>(line1.length());
    const int m = static_cast<int>(line2.length());

    vector dp(2, vector<int>(m + 1));

    for (int j = 0; j <= m; j++) {
        dp[0][j] = j;
    }

    int write_row = 1;
    int read_row = 0;

    for (int i = 1; i <= n; i++) {
        dp[write_row][0] = i;

        for (int j = 1; j <= m; j++) {
            if (line1[i-1] == line2[j-1]) {
                dp[write_row][j] = dp[read_row][j-1];
            } else {
                dp[write_row][j] = min(dp[read_row][j] + 1, min(dp[write_row][j-1] + 1, dp[read_row][j-1] + 1));
            }
        }

        swap(write_row, read_row);
    }

    cout << dp[read_row][m] << endl;
}
