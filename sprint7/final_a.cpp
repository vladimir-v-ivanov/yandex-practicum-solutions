/*
Отчет: https://contest.yandex.ru/contest/25597/run-report/140359964/

Принцип работы:
    Применен алгоритм Вагнера-Фишера.
    Массив dp представляет собой матрицу N+1 на M+1, по длинам обеих строк.
    При проходе вложенными циклами по строкам, i - по первой строке и j - по второй строке, то в dp[i][j] хранится число -
    количество минимальных изменений на текущих позициях, которые нужно было сделать, чтобы превратить первую строку во вторую.
    Базовый случай для задачи это заранее вычисленное количество изменений для строк с 0 символов.
    Например, если первая строка пустая, то dp[1][0] = 1, dp[2][0] = 2 и т.д. Что означает добавить все символы второй строки в первую.
    И точно так же, если вторая строка пустая, а первая нет.
    Эти действия описаны в самых первых двух циклах. Так же базовый случай для dp[0][0]=0.
    Переход динамики зависит от того, являются ли символы на текущих позициях одинаковыми или нет.
    Если символы одинаковые, то нужно знать ответ только одной подзадачи, для dp[i][j] это dp[i-1][j-1].
    Если символы разные, то нужно знать три ответа, для вариантов удаления, вставки и замены, в соответствии с алгоритмом -
    min(
        dp[i-1][j] + 1,
        dp[i][j-1] + 1,
        dp[i-1][j-1] + 1
    ).

    Ответ будет располагаться в нижнем правом углу матрицы, так как обход идет слева направо, сверху вниз.

Вычислительная сложность:
    Вычислительная сложность O(N * M), где N и M это длины обеих строк.

Пространственная сложность:
    Пространственная сложность O(N * M), где N и M это длины обеих строк.
*/

#include <iostream>
#include <vector>

using namespace std;

int main() {
    string line1;
    string line2;
    getline(cin,line1);
    getline(cin,line2);

    const int n = static_cast<int>(line1.length());
    const int m = static_cast<int>(line2.length());

    vector dp(n + 1, vector<int>(m + 1));
    dp[0][0] = 0;

    for (int i = 1; i <= n; i++) {
        dp[i][0] = i;
    }

    for (int j = 1; j <= m; j++) {
        dp[0][j] = j;
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (line1[i-1] == line2[j-1]) {
                dp[i][j] = dp[i-1][j-1];
            } else {
                dp[i][j] = min(dp[i-1][j] + 1, min(dp[i][j-1] + 1, dp[i-1][j-1] + 1));
            }
        }
    }

    cout << dp[n][m] << endl;
}
